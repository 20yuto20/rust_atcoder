# ABC081/B 問題解説

## 問題の概要
配列の全ての要素を同時に2で何回割り切れるかを求める問題

## コードの詳細解説

### 1. ライブラリの読み込み
```rust
use proconio::input;
```
解説: procionio ライブラリから input マクロを使用可能にする

### 2. 入力の受け取り
```rust
input! {
    n: usize,
    a: [usize; n]
}
```
解説:
- n: 配列の要素数
- a: n個の整数からなる配列

### 3. 変数の初期化
```rust
let mut b = 0;
let mut ans = 0;
```
解説:
- b: ビットOR演算の結果を格納
- ans: 2で割り切れる回数をカウント

### 4. ビットOR演算とは

#### 基本概念
- ビット: コンピュータが使う0と1の表現
- OR演算: どちらか片方でも1なら1

#### OR演算の規則
```
0 OR 0 = 0
0 OR 1 = 1
1 OR 0 = 1
1 OR 1 = 1
```

#### 具体例
```
  010  (2)
| 100  (4)
------
  110  (6)
```

### 5. 全要素のビットOR計算
```rust
for i in 0..n {
    b = a[i] | b;
}
```

#### なぜビットORを使うのか？
目的: どの桁に1があるかを調べるため

#### 具体例
配列が [8, 12, 4] の場合:
```
8  = 1000
12 = 1100
4  = 0100

結果:
  1000  (8)
| 1100  (12)
| 0100  (4)
--------
  1100  (結果)
```

重要: 末尾の0の個数 = 全ての数が2で割り切れる回数

### 6. ビットAND演算とは

#### 基本概念
両方とも1の時だけ1という計算

#### AND演算の規則
```
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1  ← 両方1の時だけ1
```

### 7. 右シフト演算とは

#### >> の意味
ビットを右にずらすという操作

#### 具体例
```rust
let a = 12;        // 1100 (2進数)
let b = a >> 1;    // 0110 = 6
let c = a >> 2;    // 0011 = 3
```

#### 数学的意味
2で割るのと同じ
```
12 >> 1 = 6    // 12 ÷ 2 = 6
12 >> 2 = 3    // 12 ÷ 4 = 3
```

### 8. 末尾の0をカウント
```rust
while (b & 1) == 0 {
    b = b >> 1;
    ans += 1;
}
```

#### 処理の流れ
1. (b & 1): 最後の桁が1かチェック
2. == 0: 最後の桁が0なら続行
3. b >> 1: 右に1つずらす（2で割る）
4. ans += 1: カウントを増やす

#### 具体例（b = 1100の場合）
```
最初: b = 1100 (12)

1回目:
- (1100 & 0001) == 0 ? → 0000 == 0 ? → YES
- b = 1100 >> 1 = 0110 (6)
- ans = 1

2回目:
- (0110 & 0001) == 0 ? → 0000 == 0 ? → YES
- b = 0110 >> 1 = 0011 (3)
- ans = 2

3回目:
- (0011 & 0001) == 0 ? → 0001 == 0 ? → NO
- ループ終了

結果: ans = 2
```

### 9. 結果の出力
```rust
println!("{}", ans);
```

## アルゴリズムのまとめ

1. 全要素のビットORを計算 → どの桁に1があるかを把握
2. 末尾の0の個数をカウント → 全ての数が2で何回割り切れるかを求める

このアプローチにより、効率的に答えを求めることができます。